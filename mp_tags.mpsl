/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Tags.

    Copyright (C) 1991-2006 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/* default ctags command */
mp.config.ctags_cmd = "ctags *";

/* editor actions */

mp.actions['find_tag']	= sub(d) {

	local tag = mp.get_word(d);

	/* ask for it, taking the word under the cursor */
	if((tag = mp.readline(L("Tag to find:"), 'find_tag', tag)) != NULL)
	{
		local t, a;

		t = [];

		mp.load_tags(1);

		/* FIXME: grep candidate */
		foreach(a, keys(mp.tags))
			if(regex('/' ~ tag ~ '/', a))
				push(t, mp.tags[a]);

		if(size(t) == 0)
		{
			mp.alert(L("Tag not found."));
			return;
		}

		/* build a list to ask the user */
		local l = [];

		/* FIXME: map candidate */
		foreach(a, t)
			push(l, a.label);

		/* only one? pre-select */
		if(size(t) == 1)
			a = 0;
		else
		if((a = mp.list(L("Select tag"), l)) == -1)
			return;

		tag = t[a].tag;

		mp.open_tag(tag);
	}
};


/* Default key bindings */

mp.keycodes['ctrl-t']	=	"find_tag";

/* action descriptions */

mp.actdesc['find_tag']	=	LL("Find tag...");

/* code */

sub mp.load_tags(force)
/* load a 'tags' file */
{
	local f, l, a;

	if((f = open("tags", "r")) == NULL)
	{
		/* if force is set, execute the ctags command */
		if((f = popen(mp.config.ctags_cmd, "r")) == NULL)
			return;

		/* read (and discard) a line from it */
		read(f);
		pclose(f);

		/* try again */
		if((f = open("tags", "r")) == NULL)
			return;
	}

	/* deletes all currently stored tags from the word/color cache */
	foreach(l, keys(mp.tags))
		hdel(mp.word_color, l);

	/* reset current tags */
	mp.tags = {};

	/* get the attribute for tags */
	a = mp.colors.tag.attr;

	while((l = read(f)))
	{
		local t = split("\t", l);
		local l, r;

		/* clean the regex 'markup' for the label */
		l = sregex('/^\/\^/', t[2], '');
		l = sregex('/\$\/;"$/', l, '') ~ ' [' ~ t[1] ~ ']';

		/* clean the regex itself */
		r = sregex('/;"$/', t[2], '');
		r = sregex('/\(/g', r, '\(');
		r = sregex('/\)/g', r, '\)');
		r = sregex('/\*/g', r, '\*');
		r = sregex('/\?/g', r, '\?');

		/* store the tag information */
		mp.tags[t[0]] = {
			'tag'	=> t[0],
			'file'	=> t[1],
			'regex'	=> r,
			'label' => l
			};

		/* store the word as specially-colored */
		mp.word_color[t[0]] = a;
	}

	close(f);
}


sub mp.open_tag(tag)
/* opens a tag */
{
	local doc, t;

	/* read the tag file (forcing) */
	mp.load_tags(1);

	/* doesn't exist? return */
	if((t = mp.tags[tag]) == NULL)
		return(NULL);

	/* open the file */
	doc = mp.open(t.file);

	/* move up and search */
	mp.move_bof(doc);
	return(mp.search(doc, t.regex));
}
