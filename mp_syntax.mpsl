/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Syntax highlight definitions.

    Copyright (C) 1991-2006 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/* editor actions */

mp.actions['help']	=	sub (d) {
	local w, h, r;

	/* get the special word regex separator for help (if any) */
	r = d.syntax.help_word_regex;

	/* if there is a word at the cursor position,
	   try searching for help */
	if((w = mp.get_word(d, r)) != NULL)
		h = mp.help(d, w);

	if(h == NULL)
		mp.alert(sprintf(L("No help for '%s'."), w));
	else
	{
		mp.new();

		d = mp.active();
		d.txt.lines = h;
		d.name = sprintf(L("<help on '%s'>"), w);
	}
};

/* default key bindings */

mp.keycodes['f1']	=	"help";

/* action descriptions */

/* data */

mp.syntax = {};

/* code */

sub mp.syn_token_list(l) { '/\b(' ~ join("|", l) ~ ')\b/'; }

mp.syntax.c = {
	'id'		=>	'c',
	'name'		=>	'C / C++',
	'filenames'	=>	[ '/\.c$/', '/\.h$/', '/\.l$/', '/\.y$/',
				'/\.cpp$/', '/\.hpp$/', '/\.c++$/', '/\.xpm$/' ],
	'help'		=>	[ "man 2 %s", "man 3 %s" ],
	'tokens'	=>	[
				mp.syn_token_list( [
				"for", "while", "if", "switch", "case", "do",
				"else", "break", "continue", "return",
				"default", "goto", "main", "fopen", "fclose",
				"fgets", "fgetc", "fputs", "fputc", "fprintf",
				"putc", "printf", "sprintf", "strcpy", "strcat",
				"strcmp", "strncmp", "strtok", "stricmp", "strchr",
				"strrchr", "strlen", "memcmp", "memcpy", "malloc",
				"free", "strncpy", "strncat", "snprintf", "strstr",
				"memset", "memcpy", "va_start", "va_end", "vsprintf",
				"vsnprintf", "atoi", "qsort", "bsearch", "getenv",
				"fscanf", "popen", "pclose", "realloc", "fread",
				"fwrite", "fseek", '\{', '\}', "putchar", "fflush",
				"wcscmp", "swprintf", "wmemcpy", "swscanf", "sscanf",
				"wcslen", "wmemset", "wcscpy", "wcsncpy",
				"mbstowcs", "wcstombs", "wprintf", "wcschr",
				"wcsrchr", "wcsstr", "strdup", "wctomb", "mbtowc",
				"mbrtowc", "wcrtomb", "open", "close", "read",
				"write", "pipe", "fork", "dup", "dup2", "wait",
				"execl", "execlp", "execle", "execv", "execvp"
				])
	],
	'variables'	=>	[
				mp.syn_token_list( [
				"char", "int", "long", "struct", "union", "const",
				"void", "unsigned", "signed", "auto", "volatile",
				"enum", "typedef", "float", "double", "extern",
				"register", "short", "sizeof", "static", "far",
				"near", "defined", "va_list", "size_t", "wchar_t",
				"iconv_t" ]),
				'/[-=<>:\?\+\*\/\!\%&\|]+/'
	],
	'comments'	=>	[
		[ '|/\*|', '|\*/|' ],			/* C-like */
		'|//.*$|m',				/* C++ */
		'/^\s*#[a-z]+/m'			/* CPP directives */
		],
	'quotes'	=>	[
		/* from http://ad.hominem.org/log/2005/05/quoted_strings.php */
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/",	/* single-quoted strings */
		"/\b-?[0-9]+\b/",			/* numbers */
		"/\b0x[0-9a-f]+\b/i",			/* hex numbers */
		"/\b[[:upper:]_]+\b/"			/* all-caps words */
		]
};

mp.syntax.rc = {
	'id'		=>	'rc',
	'name'		=>	'Resource file',
	'filenames'	=>	[ '/\.rc$/' ],
	'tokens'	=>	[ ],
	'variables'	=>	[ ],
	'comments'	=>	clone(mp.syntax.c.comments),
	'quotes'	=>	clone(mp.syntax.c.quotes)
};

mp.syntax.perl = {
	'id'		=>	'perl',
	'name'		=>	'Perl',
	'filenames'	=>	[ '/\.pl$/i', '/\.pm$/' ],
	'help'		=>	[ 'perldoc -f %s', 'perldoc %s' ],
	'help_word_regex' =>	'/[A-Z_][A-Z0-9_:]*/i',
	'tokens'	=>	[
				mp.syn_token_list( [
				"for", "if", "next", "last", "else", "elsif",
				"unless", "while", "shift", "unshift", "push",
				"pop", "delete", "new", "bless", "return",
				"foreach", "keys", "values", "sort", "grep",
				"tr", "length", "system", "exec", "fork", "map",
				"print", "write", "open", "close", "chop",
				"chomp", "exit", "sleep", "split", "join",
				"sub", "printf", "sprintf", "s", "glob",
				"scalar", "my", "local", "undef", "defined",
				"use", "package", "require", "ref", "can", "isa",
				"qw", "qq", "eq", "ne", "or", "exists",
				"and", "not", "import", "our", "caller" ]),
				'/[\{\}]/',
				'/->/'
	],
	'variables'	=>	[
				'/[:\?\+\*\/\!\$@\%&\|~\.]+/',
				'/[\$@%]\w+/'
	],
	'comments'	=>	[
		"/#.*$/m",				/* Comments */
		"/__END__\n.*$/",			/* __END__ */
		[ "/^=(head[1-4]|over|item|back|pod|begin|end|for)/m",
			"/^=cut$/m" ]			/* POD */
	],
	'quotes'	=>	[
		/* from http://ad.hominem.org/log/2005/05/quoted_strings.php */
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/",	/* single-quoted strings */
		"/\b-?[0-9]+\b/",			/* numbers */
		"/\b0x[0-9a-f]+\b/i",			/* hex numbers */
		[ "/q\(/", "/\)/" ],			/* quote */
		[ "/qw\(/", "/\)/" ],			/* quote word */
		'/\w+\s*=>/',
		[ "/<<[\"']?EOF.*$/m", "/^EOF$/m" ]	/* 'document here' */
	],
	'detect'	=>	sub (d) {
		/* take the first line */
		local f = d.txt.lines[0];

		/* is it a 'she-bang' for Perl? */
		return(regex('/^#!/usr/bin/(env )?perl/', f));
	}
};


mp.syntax.mpsl = {
	'id'		=>	'mpsl',
	'name'		=>	'MPSL',
	'filenames'	=>	[ '/\.mpsl$/' ],
	'tokens'	=>	[
				mp.syn_token_list( [
					'if', 'else', 'while', 'foreach',
					'sub', 'break', 'return' ]),
				mp.syn_token_list( keys(MPSL.CORE) ),
				'/[\{\}]/'
	],
	'variables'	=>	[
				"/(NULL|local)/",
				'/[-=<>:\?\+\*\/\!\%&\|]+/'
	],
	'comments'	=>	clone(mp.syntax.c.comments),
	'quotes'	=>	clone(mp.syntax.c.quotes)
};

mp.syntax.sh = {
	'id'		=>	'sh',
	'name'		=>	'Shell script',
	'filenames'	=>	[ '/\.sh$/', '/makefile/i' ],
	'tokens'	=>	[
				mp.syn_token_list( [
				"if", "then", "else", "elif",
				"fi", "case", "do", "done", "esac",
				"for", "until", "while", "break",
				"in", "source", "alias", "cd",
				"continue", "echo", "eval", "exec",
				"exit", "export", "kill", "logout",
				"printf", "pwd", "read", "return",
				"shift", "test", "trap", "ulimit",
				"umask", "unset", "wait", "cp", "rm" ]),
				'/[\{\}]/'

	],
	'variables'	=>	[
				"/(local|let|set)/",
				'/[-=<>:\?\+\*\!\%&\|]+/',
				'/\$\w+/'
	],
	'comments'	=>	clone(mp.syntax.perl.comments),
	'quotes'	=>	[
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/",	/* single-quoted strings */
		"/\b-?[0-9]+\b/",			/* numbers */
		"/\b0x[0-9a-f]+\b/i",			/* hex numbers */
		[ "/\(/", "/\)/" ],			/* parens */
		[ "/`/", "/`/" ],			/* backticks */
		[ "/<<[\"']?EOF[\"']?;$/m", "/^EOF$/m" ]	/* 'document here' */
	],
	'detect'	=>	sub (d) {
		/* take the first line */
		local f = d.txt.lines[0];

		/* is it a 'she-bang' for usual shells? */
		return(regex('/^#!/bin/(sh|bash|csh|dash|ksh)/', f) ||
		       regex('/^#!/usr/bin/make -f/', f));
	}

};


mp.syntax.html = {
	'id'		=>	'html',
	'name'		=>	'HTML',
	'filenames'	=>	[ '/\.html$/', '/\.htm$/' ],
	'tokens'	=>	[
				"/<[\/]?[ \t]*(" ~
				join("|", [
				"a", "abbr", "acronym", "address",
				"area", "b", "base", "bdo", "big",
				"blockquote", "body", "br", "button",
				"caption", "center", "cite", "code", "col",
				"colgroup", "dd", "del", "dfn", "div",
				"dl", "dt", "em", "fieldset", "form",
				"h1", "h2", "h3", "h4", "h5", "h6",
				"head", "hr", "html", "i", "img",
				"input", "ins", "kbd", "label", "legend",
				"li", "link", "map", "meta", "noscript",
				"object", "ol", "optgroup", "option",
				"p", "param", "pre", "q", "samp",
				"script", "select", "small", "span",
				"strong", "style", "sub", "sup", "table",
				"tbody", "td", "textarea", "tfoot", "th",
				"thead", "title", "tr", "tt", "ul",
				"var" ] ) ~
				")[^<>]*>/i"
	],
	'variables'	=>	[
				mp.syn_token_list( [
				 "!DOCTYPE", "class", "type",
				"cellspacing", "cellpadding",
				"href", "align", "valign", "name", "lang",
				"value", "action", "width", "height",
				"content", "http-equiv", "src", "alt",
				"bgcolor", "text", "link", "vlink", "alink",
				"media" ])
	],
	'comments'	=>	[
				[ '/<!--/', '/-->/' ]
	],
	'quotes'	=>	[
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/"	/* single-quoted strings */
	]
};


sub mp.detect_syntax(doc)
/* tries to detect the syntax of a document */
{
	local n;

	doc.syntax = NULL;

	/* loops the syntax highlight definitions */
	foreach(n, keys(mp.syntax))
	{
		local ext;
		local s = mp.syntax[n];

		/* test the extensions */
		foreach(ext, s.filenames)
		{
			if(regex(ext, doc.name))
			{
				doc.syntax = s;
				return;
			}
		}
	}

	/* not by extension? try the 'detect' subroutine */
	foreach(n, keys(mp.syntax))
	{
		local s = mp.syntax[n];

		if(is_exec(s.detect) && s.detect(doc))
		{
			doc.syntax = s;
			return;
		}
	}
}


sub mp.help(doc, word)
{
	local c, h;

	foreach(c, doc.syntax.help)
	{
		local f;

		/* format the command */
		c = sprintf(c, word);

		/* pipe from it */
		if((f = popen(c, "r")) != NULL)
		{
			local l;
			h = [];

			while((l = read(f)) != NULL)
				push(h, mp.chomp(l));

			/* fails? */
			if(pclose(f) != 0)
				h = NULL;
		}

		/* is there already help? don't look for more */
		if(h != NULL)
			break;
	}

	return(h);
}
