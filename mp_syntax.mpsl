/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Syntax highlight definitions.

    Copyright (C) 1991-2019 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://triptico.com

*/

/** editor actions **/

sub mp_doc.actions.help(d) {
    local w, h, r;

    /* get the special word regex separator for help (if any) */
    r = d.syntax.help_word_regex;

    /* if there is a word at the cursor position,
        try searching for help */
    if ((w = d->get_word(r)) != NULL) {
        d->busy(1);
        h = d->help(w);
        d->busy(0);
    }

    if (h == NULL)
        mp.alert(sprintf(L("No help for '%s'."), w));
    else {
        local hd;

        hd = mp.open(sprintf(L("<help on '%s'>"), w));

        hd.txt.lines    = h;
        hd.txt.y        = 0;
        hd.read_only    = 1;
        hd.syntax       = d.syntax;
    }
}

sub mp_doc.actions.section_list(d) {
    local l = d->section_list();

    if (l == NULL)
        mp.alert(L("No detection for sections for this mode."));
    else {
        if (size(l) == 0)
            mp.alert(L("No sections were found in this document."));
        else {
            local pos = -1;

            /* set pos to the section nearest the cursor */
            foreach (e, l) {
                if (e[1] > d.txt.y)
                    break;

                pos++;
            }

            if (pos < 0 || pos > size(l))
                pos = 0;

            local r = mp.form(
                [
                    {
                        label:  L("Section list"),
                        type:   'list',
                        list:   map(l, sub (e) { e[0]; }),
                        value:  pos
                    }
                ]
            );

            if (r != NULL) {
                d->search_set_y(l[r[0]][1])->set_x(0);
            }
        }
    }
}


sub mp_doc.actions.move_section_up(d) {
    local pos = -1;

    foreach (e, d->section_list()) {
        if (e[1] >= d.txt.y)
            break;

        pos = e[1];
    }

    if (pos != -1) {
        d.txt.x = 0;
        d.txt.y = pos;
    }

    return d;
}


sub mp_doc.actions.move_section_down(d) {
    local pos = d.txt.y;

    foreach (e, d->section_list()) {
        if (e[1] > pos) {
            pos = e[1];
            break;
        }
    }

    d.txt.x = 0;
    d.txt.y = pos;

    return d;
}


/** default key bindings **/

mp_doc.keycodes['f1']               = "help";
mp_doc.keycodes['ctrl-d']           = "section_list";
mp_doc.keycodes['ctrl-cursor-up']   = "move_section_up";
mp_doc.keycodes['ctrl-cursor-down'] = "move_section_down";

/** action descriptions **/

mp.actdesc['help']              = LL("Help on word over cursor");
mp.actdesc['section_list']      = LL("Section list...");
mp.actdesc['move_section_up']   = LL("Move one section up");
mp.actdesc['move_section_down'] = LL("Move one section down");

/** data **/

mp.syntax = {};

/** syntax definitions **/

sub mp.syn_token_list(l) { '/\<(' ~ join(l, "|") ~ ')\>/'; }

mp.syntax.c = {
    id:         'c',
    name:       'C / C++',
    filenames:  [
        '/\.c$/i', '/\.h$/i', '/\.l$/i', '/\.y$/i', '/\.d$/i', '/\.hh$/i',
        '/\.cpp$/i', '/\.hpp$/i', '/\.c++$/i', '/\.cxx$/i', '/\.xpm$/i'
    ],
    help:       [ "man 2 %s", "man 3 %s" ],
    help_func:  sub (w) { mp.c_gather_help(w); },
    defs:       [
        'word1', [
            mp.syn_token_list(
                [
                    "auto", "break", "case", "catch", "class", "const", "const_cast",
                    "continue", "default", "delete", "do", "dynamic_cast", "else", "enum",
                    "explicit", "extern", "for", "friend", "goto", "if", "inline", "mutable",
                    "namespace", "new", "operator", "private", "protected", "public",
                    "register", "reinterpret_cast", "restrict", "return", "sizeof", "static",
                    "static_cast", "struct", "switch", "template", "this", "throw", "try",
                    "typedef", "typeid", "typename", "union", "using", "virtual", "volatile",
                    "while", "not", "not_eq", "xor", "xor_eq", "or",  "or_eq", "and", "and_eq",
                    "bitor", "bitand", "compl"
                ]
            )
        ],
        'word2', [
            mp.syn_token_list(
                [
                    "bool", "char", "double", "float", "int", "long", "short", "signed",
                    "unsigned", "wchar_t", "size_t", "ssize_t", "off_t", "wchar_t",
                    "ptrdiff_t", "void", "sig_atomic_t", "fpos_t", "clock_t", "time_t",
                    "va_list", "jmp_buf", "FILE", "DIR", "div_t", "ldiv_t", "mbstate_t",
                    "wctrans_t", "wint_t", "wctype_t", "complex", "int8_t", "int16_t",
                    "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
                    "int_least8_t", "int_least16_t", "int_least32_t", "int_least64_t",
                    "uint_least8_t", "uint_least16_t", "uint_least32_t", "uint_least64_t",
                    "int_fast8_t", "int_fast16_t", "int_fast32_t", "int_fast64_t",
                    "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t",
                    "intptr_t", "uintptr_t", "intmax_t", "uintmax_t"
                ]
            )
        ],
        'word3', [
            '/[-=<>:\?\+\*\/\!\%&\|~\^\.\{\}\(\)\[]+/',
            '/]/'
        ],
        'quotes', [
            /* from http://ad.hominem.org/log/2005/05/quoted_strings.php */
            "/\"([^\"\\\\\n]*(\\\\.[^\"\\\\\n]*)*)\"/", /* double-quoted strings */
            "/'([^'\\\\\n]*(\\\\.[^'\\\\\n]*)*)'/",     /* single-quoted strings */
            "/\<-?[0-9]+\>/",                           /* numbers */
            "/\<[0-9]+e[0-9]+\>/",                      /* numbers in exp format */
            "/\<0[0-7]+\>/",                            /* octal numbers */
            "/\<0x[0-9a-f]+\>/i",                       /* hex numbers */
            "/\<__(DATE|FILE|LINE|STDC|TIME|STDC_HOSTED|STDC_VERSION|func)__\>/", /* ISO macros */
            "/\<(true|false|NULL)\>/"                   /* symbolic constant names */
        ],
        'comments', [
            [ '|/\*|', '|\*/|' ],                       /* C-like */
            [ '|#if 0|', '#endif' ],                    /* CPP "comments" */
            '|//.*$|m',                                 /* C++ */
            '/^\s*#\s*[a-z]+/m'                         /* CPP directives */
        ],
        'documentation', [
            [ "|/\*\*\n|", '|\*/|' ],                   /* mp_doccer */
            '/^/\*\*.*\*\*/$/m'                         /* section mark */
        ]
    ],
    section:    [ '/(^\/\*\*.*\*\*\/$|^#pragma mark|^[A-Za-z_])/' ],
    build_targets: [
        "cc -c %s"
    ]
};


/** code **/

sub mp.get_syntax(key)
{
    local r = NULL;

    key = lc(key);

    if (exists(mp.syntax, key))
        r = mp.syntax[key];
    else {
        /* try on-demand load */
        if ((r = eval("load('syntax/" ~ key ~ ".mpsl');")) != NULL)
            mp.syntax[key] = r;

        ERROR = NULL;
    }

    return r;
}


sub mp_doc.detect_syntax(doc)
/* tries to detect the syntax of a document */
{
    doc.syntax = NULL;
    local v;

    /* try extensions */
    if ((v = doc.name->regex("/\.[^.]+$/"))) {
        v = v->sregex("/\./");
        doc.syntax = mp.get_syntax(v);
    }

    /* try full name (Makefile, etc.) */
    if (doc.syntax == NULL) {
        if ((v = doc.name->regex("/[^/]+$/"))) {
            doc.syntax = mp.get_syntax(v);
        }
    }

    if (doc.syntax == NULL) {
        /* test for she-bangs */
        v = doc.txt.lines[0];

        if (regex(v, "/^#!/")) {
            /* strip paths and possible command-line options */
            v = v->sregex("/^.*\//")->sregex("/ -.*/g");

            foreach (e, split(v, " ")) {
                if ((doc.syntax = mp.get_syntax(e))) {
                    break;
                }
            }
        }
    }

    /* not yet? try the 'detect' subroutine */
    if (doc.syntax == NULL) {
        foreach (n, keys(mp.syntax)) {
            local s = mp.syntax[n];

            if (is_exec(s.detect) && s.detect(doc)) {
                doc.syntax = s;
                break;
            }
        }
    }

    return doc;
}


sub mp_doc.help(doc, word)
{
    local h;

    foreach (c, doc.syntax.help) {
        local f;

        /* format the command */
        c = sprintf(c, word);

        /* pipe from it */
        if ((f = popen(c, "r")) != NULL) {
            local l;
            h = [];

            while ((l = read(f)) != NULL) {
                l = sregex(l, "/\x{0008}./g");
                push(h, mp.chomp(l));
            }

            /* fails? */
            if (pclose(f) != 0)
                h = NULL;
        }

        /* is there already help? don't look for more */
        if (h != NULL)
            break;
    }

    if (h == NULL && doc.syntax.help_func)
        h = doc.syntax.help_func(word);

    return h;
}


/**
 * mp_doc.section_list - Returns the list of sections of a document.
 * @doc: the document
 *
 * Applies the `section' array of regular expressions of the
 * document's syntax definition and returns it as an array of
 * line and line number pairs.
 *
 * If the document has no syntax highlight definition, or it has
 * one without a `section' definition, NULL is returned. Otherwise,
 * an array of line, line number pairs is returned (it can be
 * an empty list if the document has no recognizable sections).
 */
sub mp_doc.section_list(doc)
{
    local r;

    if (doc.syntax.section) {
        local n, l;

        r = [];

        while ((l = doc.txt.lines[n]) != NULL) {
            foreach (ex, doc.syntax.section) {
                if (regex(l, ex)) {
                    push(r, [ l, n ]);
                    break;
                }
            }

            n++;
        }
    }

    return r;
}


/**
 * mp.c_gather_help - Gathers help in C-style files
 * @word: the help term
 *
 * Searches in all applicable files for code snippets that may
 * conform help for @word (mp_doccer style help, struct or
 * function definitions, etc).
 *
 * Returns an array of text with the gathered information.
 */
sub mp.c_gather_help(word)
{
    local h = [];

    foreach (fn, glob()) {
        local f;
        local ok = 0;

        /* test if this file is relevant to C */
		foreach (ext, mp.syntax.c.filenames) {
			if (regex(fn, ext)) {
                ok = 1;
                break;
			}
        }

        if (ok && (f = open(fn, "r")) != NULL) {
            local l;
            local n = 0;

            while ((l = read(f)) != NULL) {
                n++;
                local where = fn ~ ':' ~ n ~ ':';

                l = mp.chomp(l);

                if (regex(l, "/^[ \t]*#define[ \t]+" ~ word ~ "/")) {
                    /* it's a CPP define */
                    push(h, where, l);
                }
                else
                if (regex(l, "/^[A-Za-z_]+.*[ \t]+" ~ word ~ "[ \t]*\(.*/")) {
                    /* it's a function definition or prototype */
                    push(h, where, l);
                }
                else
                if (regex(l, "/^(typedef[ \]*|static[ \]*)?struct[ \t]+.*" ~ word ~ ".*\{/")) {
                    /* it's a structure definition */
                    push(h, where, l);

                    /* add up to the end of the struct */
                    while ((l = read(f)) != NULL) {
                        n++;
                        push(h, l);

                        if (regex(l, "/^\};/"))
                            break;
                    }
                }
                else
                if (regex(l, "/^\/\*\*$/")) {
                    /* mp_doccer help: is it for this word? */
                    l = read(f);
                    n++;

                    if (regex(l, "/ \* " ~ word ~ " - /")) {
                        /* it is; dump up to a ; */
                        push(h, where, '/' ~ '**', l);

                        while ((l = read(f)) != NULL) {
                            n++;
                            if (regex(l, "/^\{/"))
                                break;

                            push(h, l);
                        }
                    }
                }
            }

            close(f);
        }
    }

    if (size(h)) {
        ins(h, sprintf(L("Gathered information on %s:"), word), 0);
        ins(h, '', 1);
    }
    else
        h = NULL;

    return h;
}
