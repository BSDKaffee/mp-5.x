mp.syntax = {};

mp.syntax.c = {
	'id'		=>	'c',
	'name'		=>	'C / C++',
	'filenames'	=>	[ '/\.c$/', '/\.h$/',
				'/\.cpp$/', '/\.hpp$/', '/\.c++$/' ],
	'tokens'	=>	[ "for", "while", "if", "switch", "case", "do",
				"else", "break", "continue", "return",
				"default", "goto", "main", "fopen", "fclose",
				"fgets", "fgetc", "fputs", "fputc", "fprintf",
				"putc", "printf", "sprintf", "strcpy", "strcat",
				"strcmp", "strncmp", "strtok", "stricmp", "strchr",
				"strrchr", "strlen", "memcmp", "memcpy", "malloc",
				"free", "strncpy", "strncat", "snprintf", "strstr",
				"memset", "memcpy", "va_start", "va_end", "vsprintf",
				"vsnprintf", "atoi", "qsort", "bsearch", "getenv",
				"fscanf", "popen", "pclose", "realloc", "fread",
				"fwrite", "fseek", "{", "}", "putchar", "fflush",
				"wcscmp", "swprintf", "wmemcpy", "swscanf", "sscanf",
				"wcslen", "wmemset", "wcscpy", "wcsncpy",
				"mbstowcs", "wcstombs", "wprintf", "wcschr",
				"wcsrchr", "wcsstr", "strdup", "wctomb", "mbtowc",
				"mbrtowc", "wcrtomb", "open", "close", "read",
				"write", "pipe", "fork", "dup", "dup2", "wait",
				"execl", "execlp", "execle", "execv", "execvp" ],
	'variables'	=>	[ "char", "int", "long", "struct", "union", "const",
				"void", "unsigned", "signed", "auto", "volatile",
				"enum", "typedef", "float", "double", "extern",
				"register", "short", "sizeof", "static", "far",
				"near", "defined", "va_list", "size_t", "wchar_t",
				"iconv_t" ],
	'comments'	=>	[
		[ '|/\*|', '|\*/|' ],			/* C-like */
		'|//.*$|m',				/* C++ */
		'/^\s*#[a-z]+/m'			/* CPP directives */
		],
	'quotes'	=>	[
		/* from http://ad.hominem.org/log/2005/05/quoted_strings.php */
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/",	/* single-quoted strings */
		"/\b-?[0-9]+\b/",			/* numbers */
		"/\b[[:upper:]_]+\b/"			/* all-caps words */
		]
};

mp.syntax.perl = {
	'id'		=>	'perl',
	'name'		=>	'Perl',
	'filenames'	=>	[ '/\.pl$/i', '/\.pm$/' ],
	'tokens'	=>	[ "for", "if", "next", "last", "else", "elsif",
				 "unless", "while", "shift", "unshift", "push",
				 "pop", "delete", "new", "bless", "return",
				 "foreach", "keys", "values", "sort", "grep",
				 "tr", "length", "system", "exec", "fork", "map",
				 "print", "write", "open", "close", "chop",
				 "chomp", "exit", "sleep", "split", "join",
				 "sub", "printf", "sprintf", "s", "tr", "glob",
				 "{", "}" ],
	'variables'	=>	[ "scalar", "my", "local", "undef", "defined",
			       "use", "package", "require", "pod", "head1",
			       "head2", "item", "cut", "over", "back",
			       "ref", "qw", "qq", "eq", "ne", "or", "exists",
			       "and", "not", "import", "our", "::", "=", "=~",
			       ".=", "==", ">", "<", ">=", "<=" ],
	'comments'	=>	[
		"/#.*$/m",				/* Comments */
		"/__END__\n.*$/",			/* __END__ */
		[ "/^=/m", "/^=cut$/m" ]		/* POD */
	],
	'quotes'	=>	[
		/* from http://ad.hominem.org/log/2005/05/quoted_strings.php */
		"/\"([^\"\\\n]*(\\.[^\"\\\n]*)*)\"/",	/* double-quoted strings */
		"/'([^'\\\n]*(\\.[^'\\\n]*)*)'/",	/* single-quoted strings */
		"/\b-?[0-9]+\b/",			/* numbers */
		[ "/q\(/", "/\)/" ],			/* quote */
		[ "/qw\(/", "/\)/" ],			/* quote word */
		[ "/<<[\"']?EOF[\"']?;$/m", "/^EOF$/m" ]	/* 'document here' */
	]
};


sub mp.detect_syntax(doc)
/* tries to detect the syntax of a document */
{
	local n;

	doc.syntax = NULL;

	/* loops the syntax highlight definitions */
	foreach(n, hkeys(mp.syntax))
	{
		local ext;
		local s = mp.syntax[n];

		/* test the extensions */
		foreach(ext, s.filenames)
		{
			if(regex(ext, doc.name))
			{
				doc.syntax = s;
				break;
			}
		}
	}

	/* if one was found, build its hl_words hash */
	if(doc.syntax && !doc.syntax.hl_words)
	{
		local h = {};

		/* HACK */
		foreach(n, doc.syntax.tokens)
			h[n] = 6;

		/* HACK */
		foreach(n, doc.syntax.variables)
			h[n] = 7;

		/* finally store */
		doc.syntax.hl_words = h;
	}
}
