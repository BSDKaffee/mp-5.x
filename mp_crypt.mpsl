/*

    Minimum Profit - A Text Editor
    Encrypting functions.

    Angel Ortega <angel@triptico.com> et al.

    This software is released into the public domain.
    NO WARRANTY. See file LICENSE for details.

*/

/** ARCFOUR (encryption) class **/

global arcfour = {
    i:      0,
    j:      0,
    S:      map(256),
    byte:   sub (a4) {
        i = (i + 1)    % 256;
        j = (j + S[i]) % 256;

        /* swap */
        local t = S[i]; S[i] = S[j]; S[j] = t;

        return S[(S[i] + S[j]) % 256];
    },
    init:   sub (a4, key) {
        /* split as an array of characters */
        local k = split(key || '');
        local n = 0;

        /* scramble */
        foreach (i, 256) {
            local t = S[i];

            n = (n + t + ord(k[i % size(k)])) % 256;

            S[i] = S[n];
            S[n] = t;
        }

        /* discard 256 bytes (as recommended in many sources) */
        foreach (i, 256)
            a4->byte();

        return a4;
    }
};


sub mp.crc16(crc, octet)
/* CRC-16-CCITT (start with 0xffff) */
{
    crc = bitor(crc->bitshr(8), crc->bitshl(8)->bitand(0xffff));
    crc = crc->bitxor(octet);
    crc = crc->bitxor(crc->bitand(0xff)->bitshr(4));
    crc = crc->bitxor(crc->bitshl(12)->bitand(0xffff));
    crc = crc->bitxor(crc->bitand(0xff)->bitshl(5));

    return crc;
}


/** editor actions **/

mp_doc.actions['set_password'] = sub(d) {
    local r = mp.form(
        [
            {
                type:   'password',
                label:  L("Password") ~ ':'
            },
            {
                type:   'password',
                label:  L("Password (again)") ~ ':'
            }
        ]
    );

    if (r != NULL) {
        if (r[0] ne r[1])
            mp.alert(L("Passwords don't match."));
        else {
            d.password  = r[0];
            d.txt.mod   = 1;
        }
    }
};


/** action descriptions **/

mp.actdesc['set_password'] = LL("Password protect...");

/** code **/

sub mp.crypt_load(fd, password)
/* loads an encrypted file into lines */
{
    local c;
    local l = '';
    local lines = [];

    /* the mpcrypt1\n\0 signature has already been read */

    /* init */
    local a4 = new(arcfour)->init(password);

    local crc = 0xffff;

    while ((c = getchar(fd)) != NULL) {
        /* decrypt byte and concat */
        c = chr(ord(c) ^ a4->byte());

        crc = crc->mp.crc16(ord(c));

        if (c eq "\n") {
            /* end of line; push it and restart */
            push(lines, l);
            l = '';
        }
        else
            l = l ~ c;
    }

    push(lines, l);

/*    print(fmt("crc16: 0x%04x", crc));
*/
    return lines;
}


sub mp.crypt_save(fd, lines, password)
/* saves the lines as an encrypted file */
{
    local nl = 0;

    /* save first the signature */
    write(fd, "mpcrypt1\n");

    /* write a \0 */
    putchar(fd, "");

    /* init */
    local a4 = new(arcfour)->init(password);

    crc = 0xffff;

    /* loop the lines */
    foreach (l, lines) {
        /* write a line separator if it's not the first line */
        if (nl)
            l = "\n" ~ l;

        /* write each char xoring with next crypto-byte */
        foreach (c, split(l)) {
            crc = crc->mp.crc16(ord(c));
            putchar(fd, chr(ord(c) ^ a4->byte()));
        }

        nl++;
    }

    close(fd);

/*    print(fmt("crc16: 0x%04x", crc));
*/
    return nl;
}


sub mp.crypt_detect(fd)
/* detects if fd is an mp encrypted file */
{
    /* is it mpcrypt1\n followed by a 0? */
    if (read(fd) eq "mpcrypt1\n" && ord(getchar(fd)) == 0)
        return 1;

    /* no; file must be reopen */
    return 0;
}
