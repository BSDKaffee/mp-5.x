/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Version Control System support

    Copyright (C) 1991-2012 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/** data **/

mp.vcs = {
    git: {
        id:     'Git',
        check:  [ '.git', '../.git', '../../.git' ],
        opts:   {
            'git diff'          => { unique_log: 1 },
            'git status'        => NULL,
            'git log'           => { unique_log: 1 },
            "git diff '%s'"     => { unique_log: 1 },
            "git log '%s'"      => { unique_log: 1 },
            "git add '%s'"      => NULL,
            "git blame '%s'"    => { unique_log: 1 },
            "git checkout '%s'" => NULL,
            "git stash"         => NULL,
            "git stash apply"   => NULL,
            "git push"          => NULL,
            "git pull"          => NULL,
            "git commit -a"     => {
                pre:    sub (doc) {
                    mp.vcs_commit_on_close(doc, "git commit -a -F '%s'", 'Git');
                }
            }
        }
    },
    svn: {
        id:     'SVN',
        check:  [ '.svn' ],
        opts:   {
            'svn diff'          => { unique_log: 1 },
            'svn status'        => NULL,
            'svn log'           => { unique_log: 1 },
            "svn diff '%s'"     => NULL,
            "svn log '%s'"      => { unique_log: 1 },
            "svn add '%s'"      => NULL,
            "svn annotate '%s'" => { unique_log: 1 },
            "svn update"        => NULL,
            "svn revert '%s'"   => NULL,
            "svn commit"        => {
                pre:    sub (doc) {
                    mp.vcs_commit_on_close(doc, "svn commit -F '%s'", 'SVN');
                }
            }
        }
    },
    mercurial: {
        id:     'Mercurial',
        check:  [ '.hg', '../.hg', '../../.hg' ],
        opts:   {
            'hg diff'          => { unique_log: 1 },
            'hg status'        => NULL,
            'hg log'           => { unique_log: 1 },
            "hg diff '%s'"     => NULL,
            "hg log '%s'"      => { unique_log: 1 },
            "hg add '%s'"      => NULL,
            "hg push"          => NULL,
            "hg pull"          => NULL,
            "hg annotate '%s'" => { unique_log: 1 },
            "hg commit -A"     => {
                pre:    sub (doc) {
                    mp.vcs_commit_on_close(doc, "hg commit -A -l '%s'", 'Mercurial');
                }
            }
        }
    }
};

/** editor actions **/

mp.actions['vcs'] = sub (d) {
    local v = NULL;

    foreach (k, keys(mp.vcs)) {
        local n = mp.vcs[k];

        foreach (d, n.check) {
            if (stat(d) != NULL) {
                v = n;
                break;
            }
        }

        if (v != NULL)
            break;
    }

    if (v == NULL)
        mp.alert(L("This directory is not under a supported version control system"));
    else {
        local l = sort(keys(v.opts));

        local t = mp.form(
            [
                {
                    label:  sprintf(L("Available %s commands"), v.id),
                    type:   'list',
                    list:   l,
                    value:  mp.vcs_target
                }
            ]
        );

        if (t != NULL) {
            mp.vcs_target = t[0];

            local opts = v.opts[l[mp.vcs_target]];
            local cmd = sprintf(l[mp.vcs_target], d.name);

            /* if a 'pre' hook exists, run it and get the
               cmd to be executed (NULL if none) */
            if (opts.pre) {
                cmd = opts.pre(d);
            }

            if (cmd != NULL) {
                local log;

                /* unique log for this command? */
                if (opts.unique_log) {
                    log = mp.open(sprintf(L("<%s output>"), cmd));
                    log.txt.lines   = [ '' ];
                    log.txt.y       = 0;
                }
                else {
                    /* common log */
                    log = mp.open(sprintf(L("<%s output>"), v.id));

                    mp.move_eof(log);
                    mp.insert(log, cmd ~ ":\n\n");
                }

                mp.actions.exec_command(log, cmd);

                if (opts.unique_log) {
                    mp.detect_syntax(log);
                    mp.move_bof(log);
                }
                else
                    mp.insert(log, "\n");

                log.txt.mod     = 0;
                log.undo        = [];
                log.read_only   = 1;
            }
        }
    }
};

/** default key bindings **/

mp.keycodes['ctrl-p'] = 'vcs';

/** action descriptions **/

mp.keycodes['vcs'] = LL("Version Control...");

/** code **/

sub mp.vcs_commit_on_close(doc, cmd, vcsname)
/* on_close handler for commit message documents */
{
    /* create a commit message */
    local ci = mp.open('.COMMIT_MESSAGE');

    ci.commit_cmd   = cmd;
    ci.log_name     = sprintf(L("<%s output>"), vcsname);

    /* and add an on_close handler */
    push(ci.on_close,
        sub (doc) {
            if (stat(doc.name)) {
                local cmd = sprintf(doc.commit_cmd, doc.name);

                local log = mp.open(doc.log_name);

                mp.move_eof(log);
                mp.insert(log, cmd ~ ":\n\n");
                mp.actions.exec_command(log, cmd);
                mp.insert(log, "\n");

                log.txt.mod     = 0;
                log.undo        = [];
                log.read_only   = 1;

                /* bring doc to active back */
                mp.open(doc.name);
            }

            unlink('.COMMIT_MESSAGE');

            /* delete this on_close handler */
            pop(doc.on_close);

            /* always close */
            return 1;
        }
    );

    return NULL;
}
