sub move_left

	if this.x > 0
		this.x--
	else
		if this->move_down then this->move_bol
	end
end


function move_down

	if this.y < this.txt->size - 1
		this.y++
		recover_x(this)
	end
end

sub move_bol
	this.x=0
end



sub insert_char(c)

	local v, w

	v=this.txt[this.y]

	if c eq "\n"

		w=splice(v, "", this.x, v->size - this.x)

		this.txt[this.y]=w[0]

		this.y++
		aexpand(this.txt, this.y, 1)
		this.txt[this.y]=w[1]

		this->move_bol
	else

		w=splice(v, c, this.x, 0)
		this.txt[this.y]=w[0]

		this->move_right
	end
end

sub delete_char

	local v, w

	v=this.txt[this.y]

	if this.x == v->size

		w=[2]
		w[0]=v
		w[1]=this.txt[this.y + 1]

		v=ajoin("", w)
		this.txt[this.y]=v
		this.txt[this.y + 1]=NULL
		acollapse(this.txt, this.y + 1, 1)
	else

		w=splice(v, "", this.x, 1)
		this.txt[this.y]=w[0]
	end

end

sub undo_store
	apush(mp.undo{this.name}, this)
	if mp.undo{this.name}->size > mp.config.undo_levels
		adel(mp.undo{this.name}, 0)
	end

	this=dup(this)
end

sub undo
	local u

	u=mp.undo{this.name}

	if u->size > 0 then this=v->apop
end

/undo {
	$mp.undo{$mp.active.name} dup
	size 0 > { apop /active #= } { pop } ifelse

	$mp.undo size 0 >
		{ /mp.active /mp.undo apop = } if
} set

/undo_store {
	/mp.undo $mp.active apush
	$mp.undo size $mp.config.undo_levels >
		{ mp.undo 0 adel } if
} set

\mp.undo{$mp.active.name} $mp.active apush
\mp.undo{$mp.active.name} size $mp.config.undo_levels > { 0 adel } if

/mp.active.x 0 =

$mp.active.y \mp.active.txt size -- < { /mp.active.y ++ } if

/* a minimum profit text cdata */
cdata
cdata.txt
cdata.txt.lines
cdata.txt.x
cdata.txt.y
cdata.txt.sel[4]
cdata.undo

#####################################################

# The new fdm language

sub move_left(cdata)
{
	if(cdata.txt.x > 0)
		cdata.txt.x = cdata.txt.x - 1;
	else
	{
		if(cdata.txt.y > 0)
		{
			move_up(cdata);
			move_eol(cdata);
		}
	}
}

sub save_undo(cdata)
{
	my levels;

	# take config number of undo's, or default
	levels=mp.config.undo_levels;
	if(levels == 0) levels=8;

	aqueue(cdata.undo, copy(cdata.txt), levels);

	cdata.modified=1;
}


sub insert_char(cdata)
{
	my line;
	my w;

	# saves undo data
	save_undo(cdata);

	# gets current line
	line=cdata.txt.lines[cdata.txt.y];

	# splice in two lines from the x cursor position
	w=splice(line, NULL, cdata.txt.x, size(line) - cdata.txt.x);

	# store first part as current line
	cdata.txt.lines[cdata.txt.y]=w[0];

	# move to next line and open room
	cdata.txt.y=cdata.txt.y + 1;
	aexpand(cdata.txt.lines, cdata.txt.y);

	# store the second part as the new line
	cdata.txt.lines[cdata.txt.y]=w[1];
}
