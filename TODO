Refactored to ties!

 * The undo data is non-functional now; a place must be found to store the
   data in. A hash with the mpdm_v t as keys is tempting, but keys are
   lost on every undo operation. There will probably be an upper structure
   or value (probably holding also the filename and such, probably just
   the originally thought cdata); this can be used as the key to undo.

#####################################################

# The new mpdm language

sub move_left(cdata)
{
	if(cdata.txt.x > 0)
		cdata.txt.x = cdata.txt.x - 1;
	else
	{
		if(cdata.txt.y > 0)
		{
			move_up(cdata);
			move_eol(cdata);
		}
	}
}

sub save_undo(cdata)
{
	my levels;

	# take config number of undo's, or default
	levels=mp.config.undo_levels;
	if(levels == 0) levels=8;

	aqueue(cdata.undo, copy(cdata.txt), levels);

	cdata.modified=1;
}


sub insert_char(cdata)
{
	my line;
	my w;

	# saves undo data
	save_undo(cdata);

	# gets current line
	line=cdata.txt.lines[cdata.txt.y];

	# splice in two lines from the x cursor position
	w=splice(line, NULL, cdata.txt.x, size(line) - cdata.txt.x);

	# store first part as current line
	cdata.txt.lines[cdata.txt.y]=w[0];

	# move to next line and open room
	cdata.txt.y=cdata.txt.y + 1;
	aexpand(cdata.txt.lines, cdata.txt.y);

	# store the second part as the new line
	cdata.txt.lines[cdata.txt.y]=w[1];
}
