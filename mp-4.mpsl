/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Copyright (C) 2005 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/*******************
	Data
********************/

/* main data */
mp={};

/* configuration */
mp.config={};

/*******************
	Code
********************/

sub mp.set_x(txt, x)
/* sets the x position */
{
	if(x < 0)
	{
		/* cursor moved left of the bol; effective cursor up + eol */
		if(txt.y > 0)
		{
			/* one line up */
			txt.y--;

			/* set x to the end of the line */
			txt.x=size(txt.lines[txt.y]);
		}
	}
	else
	{
		/* test if moved beyond end of line */
		if(x > size(txt.lines[txt.y]))
		{
			if(txt.y < size(txt.lines) - 1)
			{
				/* cursor moved right of eol;
				   effective cursor down + bol */
				txt.x=0;
				txt.y++;
			}
		}
		else
			txt.x=x;
	}
}


sub mp.set_y(txt, y)
/* sets the y position */
{
	/* if line exists... */
	if(y >= 0 && y < size(txt.lines))
	{
		/* move there */
		txt.y=y;

		/* if x is beyond last char, move to end of line */
		if(txt.x > size(txt.lines[txt.y]))
			txt.x=size(txt.lines[txt.y]);
	}
}


sub mp.move_up(txt)
/* moves one line up */
{
	mp.set_y(txt, txt.y - 1);
}


sub mp.move_down(txt)
/* moves one line down */
{
	mp.set_y(txt, txt.y + 1);
}


sub mp.move_left(txt)
/* moves one char left */
{
	mp.set_x(txt, txt.x - 1);
}


sub mp.move_right(txt)
/* moves one char right */
{
	mp.set_x(txt, txt.x + 1);
}


sub mp.move_bol(txt)
/* moves to the beginning of the line */
{
	txt.x=0;
}


sub mp.move_eol(txt)
/* moves to the end of the line */
{
	txt.x=size(txt.lines[txt.y]);
}


sub mp.move_bof(txt)
/* moves to the beginning of the file */
{
	txt.x=0;
	txt.y=0;
}


sub mp.move_eof(txt)
/* moves to the end of the file */
{
	txt.y=size(txt.lines) - 1;
	mp.move_eol(txt);
}


sub mp.insert_line(txt)
/* inserts a newline (breaks current line in two) */
{
	local c, w;

	/* gets line where cursor is */
	c=txt.lines[txt.y];

	/* deletes from cursor to end of line */
	w=splice(c, NULL, txt.x, size(c) - txt.x);

	/* set first part as current line */
	txt.lines[txt.y]=w[0];

	/* move to next line */
	txt.y++;

	/* insert a new line here */
	aexpand(txt.lines, txt.y, 1);

	/* if autoindenting... */
	if(mp.config.auto_indent)
	{
		/* extract leading blanks in the original line
		   and prepend them to the line to be inserted */
		w[1]=regex("/^[ \t]*/", c, 0) ~ w[1];
	}

	/* put second part there */
	txt.lines[txt.y]=w[1];

	/* move to bol */
	txt.x=0;
}


/* clipboard routines */

sub mp.unmark(txt)
{
	/* just destroy the mark */
	txt.mark = NULL;
}


sub mp.mark(txt)
{
	if(txt.mark == NULL)
	{
		/* no mark; create one */
		txt.mark = {};
		txt.mark.bx=txt.x;
		txt.mark.by=txt.y;
		txt.mark.ex=txt.x;
		txt.mark.ey=txt.y;
	}
	else
	{
		/* mark exists; extend current one */
		if(txt.y < txt.mark.by ||
			(txt.y == txt.mark.by && txt.x < txt.mark.bx))
		{
			/* move the beginning of the block */
			txt.mark.bx=txt.x;
			txt.mark.by=txt.y;
		}
		else
		{
			/* move the end of the block */
			txt.mark.ex=txt.x;
			txt.mark.ey=txt.y;
		}
	}
}


sub mp.copy(txt)
{
	/* no mark? done */
	if(mp.mark == NULL) return;

	/* set the clipboard to an empty array */
	mp.clipboard = [];

	if(txt.mark.by == txt.mark.ey)
	{
		local w;

		/* block is just one line; take the inside
		   part and push it onto the clipboard */

		w=splice(txt.lines[txt.mark.by], NULL,
			txt.mark.bx, txt.mark.ex - txt.mark.bx);

		apush(mp.clipboard, w[1]);
	}
	else
	{
		/* block has more than one line */
		print("TBD\n");
	}
}


t={};
t.x=3;
t.y=0;
t.lines=[ "This is", "a text", "  with some", "lines inside", "it" ];

dump(t);

print("t.x: ", t.x, "\n");

mp.set_x(t, 15);
dump(t);

mp.set_y(t, 3);
mp.set_x(t, 12);
dump(t);

mp.set_y(t, t.y + 1);
dump(t);

mp.move_bol(t);
dump(t);

mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
dump(t);

mp.insert_line(t);
dump(t);

mp.mark(t);
mp.move_up(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.mark(t);
mp.move_down(t);
mp.move_down(t);
mp.mark(t);
dump(t);

mp.config.auto_indent=1;
mp.insert_line(t);
dump(t);

mp.unmark(t);
mp.move_bof(t);
mp.move_right(t);
mp.move_right(t);
mp.mark(t);
mp.move_right(t);
mp.move_right(t);
mp.move_right(t);
mp.move_right(t);
mp.mark(t);
dump(t);

mp.copy(t);
dump(mp.clipboard);
