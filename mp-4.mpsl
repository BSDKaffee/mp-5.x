/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Copyright (C) 2005 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/*******************
	Data
********************/

/* main data */
mp={};

/* configuration */
mp.config={};
mp.config.eol="\n";

/*******************
	Code
********************/

sub mp.set_x(txt, x)
/* sets the x position */
{
	if(x < 0)
	{
		/* cursor moved left of the bol; effective cursor up + eol */
		if(txt.y > 0)
		{
			/* one line up */
			txt.y--;

			/* set x to the end of the line */
			txt.x=size(txt.lines[txt.y]);
		}
	}
	else
	{
		/* test if moved beyond end of line */
		if(x > size(txt.lines[txt.y]))
		{
			if(txt.y < size(txt.lines) - 1)
			{
				/* cursor moved right of eol;
				   effective cursor down + bol */
				txt.x=0;
				txt.y++;
			}
		}
		else
			txt.x=x;
	}
}


sub mp.set_y(txt, y)
/* sets the y position */
{
	/* if line exists... */
	if(y >= 0 && y < size(txt.lines))
	{
		/* move there */
		txt.y=y;

		/* if x is beyond last char, move to end of line */
		if(txt.x > size(txt.lines[txt.y]))
			txt.x=size(txt.lines[txt.y]);
	}
}


sub mp.move_up(txt)
/* moves one line up */
{
	mp.set_y(txt, txt.y - 1);
}


sub mp.move_down(txt)
/* moves one line down */
{
	mp.set_y(txt, txt.y + 1);
}


sub mp.move_left(txt)
/* moves one char left */
{
	mp.set_x(txt, txt.x - 1);
}


sub mp.move_right(txt)
/* moves one char right */
{
	mp.set_x(txt, txt.x + 1);
}


sub mp.move_bol(txt)
/* moves to the beginning of the line */
{
	txt.x=0;
}


sub mp.move_eol(txt)
/* moves to the end of the line */
{
	txt.x=size(txt.lines[txt.y]);
}


sub mp.move_bof(txt)
/* moves to the beginning of the file */
{
	txt.x=0;
	txt.y=0;
}


sub mp.move_eof(txt)
/* moves to the end of the file */
{
	txt.y=size(txt.lines) - 1;
	mp.move_eol(txt);
}


sub mp.break_line(txt)
/* breaks current line in two (inserts a newline) */
{
	local c, w;

	/* gets line where cursor is */
	c=txt.lines[txt.y];

	/* deletes from cursor to end of line */
	w=splice(c, NULL, txt.x, -1);

	/* set first part as current line */
	txt.lines[txt.y]=w[0];

	/* move to next line */
	txt.y++;

	/* insert a new line here */
	aexpand(txt.lines, txt.y, 1);

	/* if autoindenting... */
	if(mp.config.auto_indent)
	{
		/* extract leading blanks in the original line
		   and prepend them to the line to be inserted */
		w[1]=regex("/^[ \t]*/", c, 0) ~ w[1];
	}

	/* put second part there */
	txt.lines[txt.y]=w[1];

	/* move to bol */
	txt.x=0;
}


sub mp.join_line(txt)
/* joins the current line with the next one */
{
	if(txt.y < size(txt.lines))
	{
		/* concats current line with the next one */
		txt.lines[txt.y] = txt.lines[txt.y] ~ txt.lines[txt.y + 1];

		/* collapse */
		acollapse(txt.lines, txt.y + 1);
	}
}


sub mp.insert(txt, str)
/* inserts a string into the cursor position */
{
	local w;

	/* splice and change */
	w=splice(txt.lines[txt.y], str, txt.x, 0);
	txt.lines[txt.y] = w[0];

	/* move right */
	txt.x += size(str);

	/* if wordwrapping... */
	if(mp.config.wordwrap > 0 && size(w[0]) > mp.config.wordwrap)
	{
		print("TBD\n");
	}
}


/* clipboard routines */

sub mp.unmark(txt)
{
	/* just destroy the mark */
	txt.mark = NULL;
}


sub mp.mark(txt)
{
	if(txt.mark == NULL)
	{
		/* no mark; create one */
		txt.mark = {};
		txt.mark.bx=txt.x;
		txt.mark.by=txt.y;
		txt.mark.ex=txt.x;
		txt.mark.ey=txt.y;
	}
	else
	{
		/* mark exists; extend current one */
		if(txt.y < txt.mark.by ||
			(txt.y == txt.mark.by && txt.x < txt.mark.bx))
		{
			/* move the beginning of the block */
			txt.mark.bx=txt.x;
			txt.mark.by=txt.y;
		}
		else
		{
			/* move the end of the block */
			txt.mark.ex=txt.x;
			txt.mark.ey=txt.y;
		}
	}
}


sub mp.copy(txt)
{
	/* no mark? done */
	if(txt.mark == NULL) return;

	/* set the clipboard to an empty array */
	mp.clipboard = [];

	if(txt.mark.by == txt.mark.ey)
	{
		local w;

		/* block is just one line; take the inside
		   part and push it onto the clipboard */

		w=splice(txt.lines[txt.mark.by], NULL,
			txt.mark.bx, txt.mark.ex - txt.mark.bx);

		apush(mp.clipboard, w[1]);
	}
	else
	{
		local w, n;

		/* block has more than one line */

		/* take from the beginning to the end of the first line */
		n=txt.mark.by;
		w=splice(txt.lines[n], NULL, txt.mark.bx, -1);

		apush(mp.clipboard, w[1]);
		n++;

		/* take the central lines */
		while(n < txt.mark.ey)
			apush(mp.clipboard, txt.lines[n++]);

		/* take the last line */
		w=splice(txt.lines[n], NULL, 0, txt.mark.ex);
		apush(mp.clipboard, w[1]);
	}
}


sub mp.delete_mark(txt)
{
	/* no mark? done */
	if(txt.mark == NULL) return;

	if(txt.mark.by == txt.mark.ey)
	{
		local w;

		/* block is just one line; delete the middle part */
		w=splice(txt.lines[txt.mark.by], NULL,
			txt.mark.bx, txt.mark.ex - txt.mark.bx);

		txt.lines[txt.mark.by] = w[0];
	}
	else
	{
		local w;

		/* block has more than one line */

		/* delete from the beginning to the end of the first line */
		w=splice(txt.lines[txt.mark.by], NULL, txt.mark.bx, -1);
		txt.lines[txt.mark.by] = w[0];

		/* delete from the beginning of the last line to
		   the end of the block */
		w=splice(txt.lines[txt.mark.ey], NULL, 0, txt.mark.ex);
		txt.lines[txt.mark.ey] = w[0];

		/* collapse the lines in between */
		acollapse(txt.lines, txt.mark.by, txt.mark.ey - txt.mark.by);
	}

	/* in any case, move to the start of the block and unmark */
	txt.x=txt.mark.bx;
	txt.y=txt.mark.by;
	mp.unmark(txt);
}


sub mp.paste(txt)
/* pastes from the clipboard into a text */
{
	local s;

	/* no clipboard? return */
	if(mp.clipboard == NULL)
		return;

	/* empty clipboard (rare, but possible)? return */
	if((s=size(mp.clipboard)) == 0)
		return;

	/* paste first line into current position */
	mp.insert(txt, mp.clipboard[0]);

	/* more than just one line? */
	if(s > 1)
	{
		/* break current line in two */
		mp.break_line(txt);

		/* insert last line */
		mp.insert(txt, mp.clipboard[s - 1]);
	}

	/* more than two lines? */
	if(s > 2)
	{
		local n=1;

		/* open room */
		aexpand(txt.lines, txt.y, s - 2);

		/* transfer middle lines */
		while(n < s - 1)
			txt.lines[txt.y++]=mp.clipboard[n++];
	}
}


/* file code */

sub mp.chomp(str)
/* chomps the end of file chars from a string */
{
	sregex("/" ~ mp.config.eol ~ "$/", str, NULL);
}


sub mp.load_file(txt, filename)
/* loads a file from disk */
{
	local f, l;

	/* open or fail */
	if((f=open(filename, "r")) == NULL)
		return(0);

	/* set lines as an empty array */
	txt.lines = [];

	/* read the file into it */
	while((l=read(f)) != NULL)
		apush(txt.lines, mp.chomp(l));

	close(f);

	mp.move_bof(txt);

	return(1);
}


t={};
t.x=3;
t.y=0;
t.lines=[ "This is", "a text", "  with some", "lines inside", "it" ];

dump(t);

print("t.x: ", t.x, "\n");

mp.set_x(t, 15);
dump(t);

mp.set_y(t, 3);
mp.set_x(t, 12);
dump(t);

mp.set_y(t, t.y + 1);
dump(t);

mp.move_bol(t);
dump(t);

mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
dump(t);

mp.break_line(t);
dump(t);

mp.mark(t);
mp.move_up(t);
mp.move_left(t);
mp.move_left(t);
mp.move_left(t);
mp.mark(t);
mp.move_down(t);
mp.move_down(t);
mp.mark(t);
dump(t);

mp.config.auto_indent=1;
mp.break_line(t);
dump(t);

mp.unmark(t);
mp.move_bof(t);
mp.move_right(t);
mp.move_right(t);
mp.mark(t);
mp.move_right(t);
mp.move_right(t);
mp.move_right(t);
mp.move_right(t);
mp.mark(t);
dump(t);

mp.copy(t);
dump(mp.clipboard);

mp.move_down(t);
mp.move_down(t);
mp.mark(t);
mp.copy(t);
dump(mp.clipboard);

mp.load_file(t, "TODO");
dump(t);
mp.mark(t);
mp.move_down(t);
mp.move_down(t);
mp.move_down(t);
mp.mark(t);
mp.copy(t);
dump(t);
mp.move_eof(t);
mp.move_eol(t);
print("paste...\n");
mp.paste(t);
print("ok\n");
dump(t);
dump(mp.clipboard);
