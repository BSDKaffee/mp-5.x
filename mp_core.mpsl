/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    Copyright (C) 1991-2006 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/*******************
	Data
********************/

/* configuration */
mp.config = {};
mp.config.eol = "\n";
mp.config.undo_levels = 20;
mp.config.wordwrap = 0;
mp.config.auto_indent = 0;
mp.config.status_format = "%m %x,%y [%l] %R%O %s %t";

/* document list */
mp.docs = [];
mp.active = 0;

/* status line directives */
mp.status_f = {};

/*******************
	Code
********************/

sub mp.store_undo(doc)
/* stores the current txt in the undo queue */
{
	queue(doc.undo, clone(doc.txt), mp.config.undo_levels);
}


sub mp.undo(doc)
/* undoes last operation */
{
	local txt;

	if(txt = pop(doc.undo)) doc.txt = txt;
}


sub mp.get_word(doc)
/* returns the word under the cursor */
{
	local txt, r, c, l;

	txt = doc.txt;
	l = txt.lines[txt.y];

	/* loop all words in current line */
	while(r = regex("/\w+/", l, c[0] + c[1]))
	{
		/* get coordinates */
		c = regex();

		/* if matching coords are between the cursor, got it */
		if(c[0] <= txt.x && c[0] + c[1] >= txt.x)
			break;
	}

	return(r);
}


sub mp.new()
/* creates a new document */
{
	local doc, txt;

	txt = {};
	txt.x = 0;
	txt.y = 0;
	txt.vx = 0;
	txt.vy = 0;
	txt.lines = [ '' ];

	doc = {};
	doc.name = "<unnamed>";
	doc.txt = txt;

	doc.undo = [];

	doc.window = {};

	doc.syntax = NULL;

	/* store in the list and set as active */
	push(mp.docs, doc);
	mp.active = size(mp.docs) - 1;

	return(doc);
}


sub mp.next()
/* rotates through the document list */
{
	if(++mp.active == size(mp.docs))
		mp.active = 0;
}


sub mp.close()
/* closes the active document */
{
	local k = mp.active;

	/* delete from the list */
	adel(mp.docs, mp.active);

	/* rotate if it was the last one */
	if(mp.active == size(mp.docs))
		mp.active = 0;
}


sub mp.open(filename)
/* opens a new document */
{
	local d;

	d = mp.new();
	mp.load_file(d, filename);
}


/*******************************************************/

mp.colors = {
	'normal' => {		'text'	=> [ 'default', 'default' ],
				'gui'	=> [ 0x000000, 0xffffff ] },
	'cursor' => {		'text'	=> [ 'default', 'default' ],
				'gui'	=> [ 0x000000, 0xffffff ],
				'flags' => [ 'reverse' ] },
	'selection' => {	'text'	=> [ 'red', 'default' ],
				'gui'	=> [ 0xff0000, 0xffffff ],
				'flags'	=> [ 'reverse'] },
	'comments' => {		'text'	=> [ 'green', 'default' ],
				'gui'	=> [ 0x00cc77, 0xffffff ] },
	'quotes' => {		'text'	=> [ 'blue', 'default' ],
				'gui'	=> [ 0x0000ff, 0xffffff ],
				'flags'	=> [ 'bright' ] },
	'matching' => {		'text'	=> [ 'black', 'cyan' ],
				'gui'	=> [ 0x000000, 0xffff00 ] },
	'word1' => {		'text'	=> [ 'green', 'default' ],
				'gui'	=> [ 0x00aa00, 0xffffff ],
				'flags'	=> [ 'bright' ] },
	'word2' => {		'text'	=> [ 'red', 'default' ],
				'gui'	=> [ 0xff6666, 0xffffff ],
				'flags' => [ 'bright' ] },
	'tag' => {		'text'	=> [ 'cyan', 'default' ],
				'gui'	=> [ 0x8888ff, 0xffffff ],
				'flags'	=> [ 'bright', 'underline' ] }
};

mp.keycodes = {
	'cursor-left'	=>	'move-left',
	'cursor-right'	=>	'move-right',
	'cursor-up'	=>	'move-up',
	'cursor-down'	=>	'move-down',
	'page-up'	=>	'move-pgup',
	'page-down'	=>	'move-pgdn',
	'home'		=>	'move-bol',
	'end'		=>	'move-eol',
	'ctrl-home'	=>	'move-bof',
	'ctrl-end'	=>	'move-eof',

	'ctrl-cursor-left'	=>	NULL,
	'ctrl-cursor-right'	=>	'move-word-right',

	'enter'		=>	'insert-line',
	'tab'		=>	'insert-tab',
	'space'		=>	'insert-space',
	'delete'	=>	'delete',
	'backspace'	=>	'delete-left',

	'f8'		=>	'unmark',
	'f9'		=>	'mark',

	'ctrl-a'	=>	NULL,
	'ctrl-b'	=>	NULL,
	'ctrl-c'	=>	'copy-mark',
	'ctrl-d'	=>	NULL,
	'ctrl-e'	=>	NULL,
	'ctrl-g'	=>	'goto',
	'ctrl-h'	=>	NULL,
	'ctrl-i'	=>	'insert-tab',
	'ctrl-j'	=>	NULL,
	'ctrl-k'	=>	NULL,
	'ctrl-l'	=>	NULL,
	'ctrl-m'	=>	'insert-line',
	'ctrl-n'	=>	'next',
	'ctrl-o'	=>	'open',
	'ctrl-p'	=>	NULL,
	'ctrl-q'	=>	'exit',
	'ctrl-r'	=>	'replace',
	'ctrl-s'	=>	'save',
	'ctrl-t'	=>	NULL,
	'ctrl-u'	=>	NULL,
	'ctrl-v'	=>	'paste-mark',
	'ctrl-w'	=>	'close',
	'ctrl-x'	=>	'cut-mark',
	'ctrl-y'	=>	'delete-line',
	'ctrl-z'	=>	'undo'
};

mp.actions = {

	'move-left'	=>	sub (d) { mp.move_left(d); },
	'move-right'	=>	sub (d) { mp.move_right(d); },
	'move-up'	=>	sub (d) { mp.move_up(d); },
	'move-down'	=>	sub (d) { mp.move_down(d); },
	'move-pgup'	=>	sub (d) { mp.move_pgup(d); },
	'move-pgdn'	=>	sub (d) { mp.move_pgdn(d); },
	'move-bol'	=>	sub (d) { mp.move_bol(d); },
	'move-eol'	=>	sub (d) { mp.move_eol(d); },
	'move-bof'	=>	sub (d) { mp.move_bof(d); },
	'move-eof'	=>	sub (d) { mp.move_eof(d); },

	'move-word-right'	=>	sub(d) { mp.move_word_right(d); },

	'unmark'	=>	sub (d) { mp.unmark(d); },
	'mark'		=>	sub (d) { mp.mark(d); },
	'copy-mark'	=>	sub (d) {
						mp.copy(d);
						mp.unmark(d);
						mp.drv.clip_to_sys();
					},
	'paste-mark'	=>	sub (d) {
						mp.store_undo(d);
						mp.drv.sys_to_clip();
						mp.paste(d);
					},
	'cut-mark'	=>	sub (d) {
						mp.store_undo(d);
						mp.cut(d);
						mp.drv.clip_to_sys();
					},

	'insert-line'	=>	sub (d) { mp.store_undo(d); mp.break_line(d); },
	'delete-line'	=>	sub (d) { mp.store_undo(d); mp.delete_line(d); },
	'insert-space'	=>	sub (d) { mp.store_undo(d); mp.insert_space(d); },
	'insert-tab'	=>	sub (d) { mp.store_undo(d); mp.insert(d, "\t"); },

	'delete'	=>	sub (d) { mp.store_undo(d); mp.delete_char(d); },
	'delete-left'	=>	sub (d) { mp.store_undo(d); mp.move_left(d);
					mp.delete_char(d); },

	'save'		=>	sub (d) { mp.save_file(d); },
	'next'		=>	sub (d) { mp.next(); },
	'close'		=>	sub (d) { mp.close(); },

	'undo'		=>	sub (d) { mp.undo(d); },

	'exit'		=>	sub (d) { mp.exit(); }

};


sub mp.get_active()
/* returns the active document */
{
	local d;

	/* empty document list? create a new, empty one */
	if(size(mp.docs) == 0)
		mp.new();

	/* get active document */
	d = mp.docs[mp.active];

	/* HACK */
	d.window = mp.drv.window;

	return(d);
}


sub mp.process_event(k)
/* processes a key event */
{
	local d, f;

	d = mp.get_active();

	/* get the action asociated to the keycode */
	if((f = mp.keycodes[k]) != NULL)
	{
		/* take the code and execute */
		if((f = mp.actions[f]) != NULL)
			f(d);
	}
	else
		mp.insert(d, k);
}


sub mp.build_status_line()
/* returns the string to be drawn in the status line */
{
	local d = mp.get_active();

	mp.status_f = {
		"%V"	=>	mp.VERSION,		/* version */
		"%m"	=>	"",			/* modify flag */
		"%x"	=>	d.txt.x + 1,		/* x coord */
		"%y"	=>	d.txt.y + 1,		/* y coord */
		"%l"	=>	size(d.txt.lines),	/* # of lines */
		"%R"	=>	"",			/* recording flag */
		"%O"	=>	"",			/* overwrite mode */
		"%s"	=>	d.syntax.name,		/* synhi mode */
		"%t"	=>	""			/* tag target */
	};

	return(sregex("/%\w/g", mp.config.status_format, sub (k) { mp.status_f[k]; }));
}


sub mp.process_cmdline()
/* process the command line arguments (ARGV) */
{
	local o, line;

	if(size(ARGV) <= 1)
		return;

	/* skip ARGV[0] */
	shift(ARGV);

	while(o = shift(ARGV))
	{
		if(o eq '-e')
		{
			/* execute code */
			if((o = compile(shift(ARGV))) != NULL)
				o();
			else
				print(ERROR, "\n");
		}
		else
		if(regex('/^\+/', o))
		{
			/* move to line */
			line = o - 1;
		}
		else
			mp.open(o);
	}

	/* set the first as the active one */
	mp.active = 0;

	/* if there is a line defined, move there */
	if(line != NULL)
		mp.set_y(mp.get_active(), line);
}


sub mp.ui()
/* wrapper for mp.drv.ui */
{
	mp.drv.ui();
}


load("mp_move.mpsl");
load("mp_edit.mpsl");
load("mp_file.mpsl");
load("mp_clipboard.mpsl");
load("mp_search.mpsl");
load("mp_tags.mpsl");
load("mp_syntax.mpsl");
load("mp_macro.mpsl");

/** MAIN **/

mp.process_cmdline();
mp.ui();
