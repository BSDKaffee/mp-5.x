/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    File manipulation.

    Copyright (C) 1991-2006 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/* editor actions */

mp.actions['new']	= sub (d) { mp.new(); };
mp.actions['next']	= sub (d) { mp.next(); };

mp.actions['save_as']	= sub (d) {

	local t;

	/* name is <unnamed> or something similar; ask for one */
	if((t = mp.savefile(L("Save file as:"))) == NULL)
		return;

	/* store new name */
	d.name = t;

	if(mp.save(d) == -1)
		mp.alert(sprintf(L("Error saving file: %s"), ERRNO));
};

mp.actions['save']	= sub (d) {

	if(regex("/^<.+>$/", d.name))
		mp.actions.save_as(d);
	else
	if(mp.save(d) == -1)
		mp.alert(sprintf(L("Error saving file: %s"), ERRNO));
};

mp.actions['close']	= sub (d) {

	if(d.txt.mod)
	{
		local r;
		r = mp.confirm(L("File has changed. Save changes?"));

		/* cancel? don't close */
		if(r == 0) return;
		if(r == 1) mp.actions.save(d);
	}

	mp.close();
};

mp.actions['exit']	= sub (d) {

	local s;

	while(s = size(mp.docs))
	{
		/* close current document */
		mp.actions.close(mp.docs[mp.active_i]);

		/* if the size of the list hasn't changed,
		   action was cancelled, so don't exit */
		if(s == size(mp.docs)) return;
	}

	mp.exit();
};

mp.actions['open']	= sub (d) {

	local n;

	if((n = mp.openfile(L("File to open:"))) != NULL && n ne "")
		if(mp.open(n) == NULL)
			mp.alert(sprintf("Error opening '%s': %s", n, ERRNO));
};

mp.actions['open_config_file']	= sub (d) {

	mp.open(HOMEDIR ~ ".mp.mpsl");
};

/* default key bindings */

mp.keycodes['ctrl-n']		= 'next';
mp.keycodes['ctrl-o']		= 'open';
mp.keycodes['ctrl-q']		= 'exit';
mp.keycodes['ctrl-s']		= 'save';
mp.keycodes['ctrl-w']		= 'close';

mp.keycodes['close-window'] 	= 'exit';

/* action descriptions */

mp.actdesc['new']	= LL("New");
mp.actdesc['save']	= LL("Save...");
mp.actdesc['save_as']	= LL("Save as...");
mp.actdesc['next'] 	= LL("Next");
mp.actdesc['open'] 	= LL("Open...");
mp.actdesc['exit'] 	= LL("Exit");
mp.actdesc['close'] 	= LL("Close");

mp.actdesc['open_config_file']		= LL("Open configuration file");
mp.actdesc['open_templates_file']	= LL("Open templates file");

/* code */

sub mp.chomp(str)
/* chomps the end of file chars from a string */
{
	sregex("/\r?\n$/", str, NULL);
}


sub mp.open_file_for_reading(filename)
/* opens a file for reading and returns the file descriptor or NULL,
   optionally setting ERRNO */
{
	local f;

	/* clear previous errors */
	ERRNO = NULL;

	if((f = open(filename, "r")) == NULL)
	{
		/* save ERRNO */
		local e = ERRNO;

		/* if a stat() can be done, it means the file
		   exists and can't be open; this is an error.
		   otherwise, it's a non-existent file, so not
		   an error for a text editor */
		if(stat(filename) != NULL)
			ERRNO = e;
		else
			ERRNO = NULL;
	}

	return(f);
}


sub mp.load(filename)
/* loads a file from disk */
{
	local f, l;
	local lines = [];

	if((f = mp.open_file_for_reading(filename)) == NULL)
	{
		if(ERRNO != NULL)
			return(NULL);

		/* file doesn't exist: new document */
	}
	else
	{
		/* file was open; read it into lines */
		while((l = read(f)) != NULL)
			push(lines, mp.chomp(l));

		/* if previous line was chomped, add an empty line */
		if(sregex())
			push(lines, '');

		close(f);
	}

	return(mp.new(filename, lines));
}


sub mp.save(doc)
/* saves a file */
{
	local f, l;
	local s = NULL;
	local nl = 0;

	/* if unlink before write is desired, do it */
	if(mp.config.unlink && (s = stat(doc.name)) != NULL)
		unlink(doc.name);

	if((f = open(doc.name, "w")) == NULL)
	{
		/* can't write? delete name */
		doc.name = L("<unnamed>");
		return(-1);
	}

	foreach(l, doc.txt.lines)
	{
		/* write a line separator if it's not the first line */
		if(nl) write(f, mp.config.eol);

		write(f, l);
		nl++;
	}

	close(f);

	doc.txt.mod = 0;

	/* set back the permissions and ownership, if available */
	if(s != NULL)
	{
		chmod(doc.name, s[2]);
		chown(doc.name, s[4], s[5]);
	}

	return(nl);
}


sub mp.new(filename, lines)
/* creates a new document */
{
	local doc, txt;

	txt = {};
	txt.x = 0;
	txt.y = 0;
	txt.vx = 0;
	txt.vy = 0;
	txt.lines = lines || [ '' ];
	txt.mod = 0;

	doc = {};
	doc.name = filename || L("<unnamed>");
	doc.txt = txt;

	doc.undo = [];

	doc.syntax = NULL;

	/* store in the list and set as active */
	push(mp.docs, doc);
	mp.active_i = size(mp.docs) - 1;

	/* store in the undo buffer */
	mp.store_undo(doc);

	/* autodetect syntax */
	mp.detect_syntax(doc);

	return(doc);
}


sub mp.next()
/* rotates through the document list */
{
	if(++mp.active_i == size(mp.docs))
		mp.active_i = 0;
}


sub mp.close()
/* closes the active document */
{
	local k = mp.active_i;

	/* delete from the list */
	adel(mp.docs, mp.active_i);

	/* rotate if it was the last one */
	if(mp.active_i == size(mp.docs))
		mp.active_i = 0;
}


sub mp.find_file_by_name(filename)
/* finds an open file by its name */
{
	local n = 0;

	while(n < size(mp.docs))
	{
		local d = mp.docs[n];

		/* it's this one? return */
		if(d.name eq filename)
			return(n);

		n++;
	}

	/* not found */
	return(-1);
}


sub mp.open(filename)
/* opens a new document */
{
	local d = mp.find_file_by_name(filename);

	/* looks first if the file is already open */
	if(d != -1)
	{
		mp.active_i = d;
		d = mp.active();
	}
	else
	{
		/* try to open */
		d = mp.load(filename);
	}

	return(d);
}
