/*

    Minimum Profit 5.x
    A Programmer's Text Editor

    File manipulation.

    Copyright (C) 1991-2006 Angel Ortega <angel@triptico.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

    http://www.triptico.com

*/

/* editor actions */

mp.actions['next']	= sub (d) { mp.next(); };

mp.actions['save']	= sub (d) {

	if(regex("/^<.+>$/", d.name))
	{
		local t;

		/* name is <unnamed> or something similar; ask for one */
		if((t = mp.drv.readline(L("Enter file name:"))) == NULL)
			return;

		/* store new name */
		d.name = t;
	}

	mp.save_file(d);
};

mp.actions['close']	= sub (d) {

	if(d.txt.mod)
	{
		local r;
		r = mp.drv.confirm(L("File has changed. Save changes?"));

		/* cancel? don't close */
		if(r == 0) return;
		if(r == 1) mp.actions.save(d);
	}

	mp.close();
};

mp.actions['exit']	= sub (d) {

	local s;

	while(s = size(mp.docs))
	{
		/* close current document */
		mp.actions.close(mp.docs[mp.active_i]);

		/* if the size of the list hasn't changed,
		   action was cancelled, so don't exit */
		if(s == size(mp.docs)) return;
	}

	mp.exit();
};

mp.actions['open']	= sub (d) {

	local n;

	if((n = mp.drv.readline(L("File to open:"))) != NULL)
		mp.open(n);
};

/* default key bindings */

mp.keycodes['ctrl-n']		= 'next';
mp.keycodes['ctrl-o']		= 'open';
mp.keycodes['ctrl-q']		= 'exit';
mp.keycodes['ctrl-s']		= 'save';
mp.keycodes['ctrl-w']		= 'close';

mp.keycodes['close-window'] 	= 'exit';

/* action descriptions */

mp.actdesc['save']	= LL("Save...");

/* code */

sub mp.chomp(str)
/* chomps the end of file chars from a string */
{
	sregex("/" ~ mp.config.eol ~ "$/", str, NULL);
}


sub mp.load_file(doc, filename)
/* loads a file from disk */
{
	local f, l;
	local txt = doc.txt;

	/* store the filename */
	doc.name = filename;

	/* open or fail */
	if((f = open(filename, "r")) == NULL)
		return(0);

	/* set lines as an empty array */
	txt.lines = [];

	/* read the file into it */
	while((l = read(f)) != NULL)
		push(txt.lines, mp.chomp(l));

	/* if previous line was chomped, add an empty line */
	if(sregex())
		push(txt.lines, '');

	close(f);

	/* move to bof and save to the undo buffer */
	mp.move_bof(doc);
	mp.store_undo(doc);

	mp.detect_syntax(doc);

	doc.txt.mod = 0;

	return(1);
}


sub mp.save_file(doc)
/* saves a file */
{
	local f, ls, l;

	if((f = open(doc.name, "w")) == NULL)
		return(0);

	/* get all lines */
	ls = clone(doc.txt.lines);

	/* write the first one */
	write(f, adel(ls, 0));

	/* write the rest, with end of lines */
	foreach(l, ls)
	{
		write(f, mp.config.eol);
		write(f, l);
	}

	close(f);

	doc.txt.mod = 0;

	return(1);
}


sub mp.new()
/* creates a new document */
{
	local doc, txt;

	txt = {};
	txt.x = 0;
	txt.y = 0;
	txt.vx = 0;
	txt.vy = 0;
	txt.lines = [ '' ];
	txt.mod = 0;

	doc = {};
	doc.name = "<unnamed>";
	doc.txt = txt;

	doc.undo = [];

	doc.syntax = NULL;

	/* store in the list and set as active */
	push(mp.docs, doc);
	mp.active_i = size(mp.docs) - 1;

	return(doc);
}


sub mp.next()
/* rotates through the document list */
{
	if(++mp.active_i == size(mp.docs))
		mp.active_i = 0;
}


sub mp.close()
/* closes the active document */
{
	local k = mp.active_i;

	/* delete from the list */
	adel(mp.docs, mp.active_i);

	/* rotate if it was the last one */
	if(mp.active_i == size(mp.docs))
		mp.active_i = 0;
}


sub mp.open(filename)
/* opens a new document */
{
	local d;

	d = mp.new();
	mp.load_file(d, filename);
}
